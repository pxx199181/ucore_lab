#<center>lab3 report</center>
* name:pxx
* id:P14226010

##练习1: 给未被映射的地址映射上物理页(需要编程)

###1. 实现过程
            这部主要就是完成do_pgfault(mm/vmm.c)函数,需要弄清楚的是产生异常的原因及种类:
            根据文章提示, 产生页访问异常的原因主要有:
		1. 目标页帧不存在(页表项全为0,即该线性地址与物理地址尚未建立映射或者已经撤销);
		2. 相应的物理页帧不在内存中(页表项非空,但Present标志位=0,比如在swap分区或磁盘文件上);
		3. 不满足访问权限(此时页表项P标志=1,但低权限的程序试图访问高权限的地址空间,或者有程序试图写只读页面).
            当出现上面情况之一,那么就会产生页面pagefault(#PF)异常。
		对于1, 直接分配一页内存即可, 如下:
```
	   ptep = get_pte(mm->pgdir, addr, 1);
	   if (ptep == NULL) {
		cprintf("no page entry\n");
		goto failed;
	   }
	   if (*ptep == NULL) {
		// no page entry (not maped)
		struct Page *page = pgdir_alloc_page(mm->pgdir, addr, perm);
		if (page == NULL) {
		    cprintf("alloc page failed\n");
		    goto failed;
		}
	   }
```
		对于2, 需要换入到内存中去, 如下:
```
	   if (!(*ptep & PTE_P)) {
		// page entry exist but page not in memory
		if (swap_init_ok) {
		    struct Page *page = NULL;
		    swap_in(mm, addr, &page);
		    perm |= PTE_P;
		    page_insert(mm->pgdir, page, addr, perm);
		    swap_map_swappable(mm, addr, page, 1);
		}
		else {
		    cprintf("no swap_init_ok but ptep is %x, failed\n",*ptep);
		    goto failed;
		}
	   }
```
		对于3, 可以检测到异常, 但是没法处理, 在前面的代码中已经把大多数的读写操作异常处理了, 只是对于页表的权限(比如
            用户权限读取内存权限的页表时)没有处理, 所以在这里对此异常进行说明, 如下:
```
	   if (!(*ptep & PTE_U)  && (error_code & 0x004)) {
		cprintf("processor was executing at user mode (1) but page entry is in supervisor mode (0) \n");
		goto failed;
	   }
```
		具体详情见代码; 

##练习2: 补充完成基于FIFO的页面替换算法(需要编程)

###1. 实现过程
		这部分的主要工作就是实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_vistim函数, 其实两部分函数的实现代码
            非常简单, 因为FIFO算法本身就比较简单, 在理解操作系统的页面替换算法原理后, 这部分填写的代码非常少.
		对于map_swappable函数来说, 这个函数的主要功能就是将可交换的页添加到一个链表里面区, 要求链表功能类似于队列, 其实就
            是插入节点和取节点分别在链表两头即可, 在这里, 我才有的是后插法, 每次添加节点到最后(也就是头节点的前面, 因为双向链表), 
            然后头头节点的下一个节点处读取要换出的页面, 这里只需要添加一句话即可, 其实这个函数的实现有一个疑问, 就是那个参数swap_in的
            含义是什么? 根据提示, 照理说应该是该页能否换出, 后来看练习中的有关说明, 貌似对于内核中的代码, 页是不能换出的, 不然效率很低, 
            所以我猜想这个可能是为后面留下的接口, 所以未予理会, 代码如下:
```
	list_add_before(head, entry);
```
		同样对于_fifo_swap_out_victim函数来说, 需要实现的就是只要从头摘除一个页面即可, 如下:
```
	list_entry_t *out_page_le = list_next(head);
	list_del(out_page_le);
	*ptr_page = le2page(out_page_le, pra_page_link);
```
		具体详情见代码; 

##练习3: 扩展练习Challenge:实现识别dirty bit的extended clock页替换算法(需要编程)
		这部分实现挺有意思的, 看练习中的提示, 这部分对于页面替换算法实现的比较好, 能够极大通过算法效率, 相关实现代码在
            lab3challenge中, 将对应的fifo命名的函数有extended_clock替换, 实现的设计思路如下:
		1. 对于这是可交换的物理页来说, 操作和fifo一样, 在此不在赘述:
		2. 对于查找换出页面算法函数_extended_clock_swap_out_victim来说, 需要将access位和dirty位分别当做查找依据, 安照(0, 0)
            (access bit 为0, dirty bit为0), (0, 1), (1, 0), (1, 1)的顺序来查找最合适换出的页面, 由于查找到(0, 0), 该页就是最合适的页,
            那么就可以直接返回, 不用继续查找下去, 对于后面的情况都需要遍历整个可交换的链表, 由于有优先顺序, 所以在这里定义一个优先级, (0, 0)
            是3, (0, 1)是2, (1, 0)是1, (1, 1)是0, 如果每个页面对应的bit位和上述值对相等时, 就代码该页面的优先级为对应的值, 只有当前页的优先
            级小于所记录的页码优先级时, 才更新记录值, 
		3. 由于access bit和dirty bit的设置是有CPU来做的, 但是清理需要自己来做, 所以在这定义一个时钟中断, 每个0.5s(是不是有的长啊?)将各
            个bit位清零. 
		查找部分实现如下:
```
     list_entry_t *le, *out_page_le;
     int rank_id = 0;
     le = head;
     out_page_le = list_next(le);
     while((le = list_next(le)) != head){

        struct Page* page = le2page(le, pra_page_link);
        pte_t *ptep = get_pte(mm->pgdir, page->pra_vaddr, 0);

        if (*ptep == NULL) {
            cprintf("error\n");
            return -1;
        }
        if (!(*ptep & PTE_P))
            continue;
        //check bit set
        int is_a, is_d;
        is_a = *ptep & PTE_A;
        is_d = *ptep & PTE_D;
        if (is_a == 0) {
            if (is_d == 0) {
                out_page_le = le;
                cprintf("find 3\n");
                break;
            }
            else if (rank_id < 2) {
                rank_id = 2;
                out_page_le = le;
                cprintf("find 2\n");
            }
        }
        else if (rank_id < 1){
            if (is_d == 0) {
                rank_id = 1;
                out_page_le = le;
                cprintf("find 1\n");
            }
        }
        cprintf("=====in raound=====\n");
     }
```
		找到后进行替换:
```
     list_del(out_page_le);
     *ptr_page = le2page(out_page_le, pra_page_link);
     cprintf("%x\n", get_pte(mm->pgdir, (*ptr_page)->pra_vaddr, 0));
     cprintf("%x\n", (*ptr_page)->pra_vaddr);
     print_swap_page_info(mm);
```
		时钟中断处理:
```
        in_swap_tick_event++;
        if (in_swap_tick_event == swap_event_trigger) {
            swap_tick_event_handler();
            in_swap_tick_event = 0;
        }
```
		swap_tick_event_handler函数如下:
```
	static int 
	swap_tick_event_handler() {
	    extern struct mm_struct *check_mm_struct;
	    if (check_mm_struct != NULL) {
		swap_tick_event(check_mm_struct);
	    }
	    panic("unhandled swap_tick_event.\n");
	}
```
		真正的tick处理函数在
		swap_tick_event_handler函数是调用的_extended_clock_tick_event函数如下:
```
    list_entry_t *head, *le;
    head = le = (list_entry_t*) mm->sm_priv;
    while((le = list_next(le) != head)) {
        struct Page* page = le2page(le, pra_page_link);
        pte_t *ptep = get_pte(mm->pgdir, page->pra_vaddr, 0);
        if (ptep == NULL) {
            cprintf("error\n");
            return -1;
        }
        //clear bit set
        *ptep &= ~(PTE_A | PTE_D);
    }
```
		对于最后运行的结果, 能够正常通过流程, 对于时钟中断后, 进入到清零处理的过程中, 会发生异常, 跟踪进去看, 发现地址很怪异, 等课上问下
            老师, 部分结果如下:
###结果 :
```
	set up init env for check_swap over!
	write Virt Page c in _extended_clock_check_swap
	write Virt Page a in _extended_clock_check_swap
	write Virt Page d in _extended_clock_check_swap
	write Virt Page b in _extended_clock_check_swap
	write Virt Page e in _extended_clock_check_swap
	page fault at 0x00005000: K/W [no page found].
	pte_addr list:
	307067->308067->309067->30a067->
	pra_addr list:
	1000->2000->3000->4000->
	=====in raound=====
	=====in raound=====
	=====in raound=====
	=====in raound=====
	c0306004
	1000
	pte_addr list:
	308067->309067->30a067->
	pra_addr list:
	2000->3000->4000->
	swap_out: i 0, store page in vaddr 0x1000 to disk swap entry 2
	write Virt Page b in _extended_clock_check_swap
	write Virt Page a in _extended_clock_check_swap
	page fault at 0x00001000: K/W [no page found].
	pte_addr list:
	308067->309067->30a067->307067->
	pra_addr list:
	2000->3000->4000->5000->
	=====in raound=====
	=====in raound=====
	=====in raound=====
	=====in raound=====
	c0306008
	2000
	pte_addr list:
	309067->30a067->307067->
	pra_addr list:
	3000->4000->5000->
	swap_out: i 0, store page in vaddr 0x2000 to disk swap entry 3
	swap_in: load disk swap entry 2 with swap_page in vadr 0x1000
	write Virt Page b in _extended_clock_check_swap
	page fault at 0x00002000: K/W [no page found].
	pte_addr list:
	309067->30a067->307067->300->
	pra_addr list:
	3000->4000->5000->2000->
	=====in raound=====
	=====in raound=====
	=====in raound=====
	c030600c
	3000
	pte_addr list:
	30a067->307067->300->
	pra_addr list:
	4000->5000->2000->
	swap_out: i 0, store page in vaddr 0x3000 to disk swap entry 4
	swap_in: load disk swap entry 3 with swap_page in vadr 0x2000
	write Virt Page c in _extended_clock_check_swap
	page fault at 0x00003000: K/W [no page found].
	pte_addr list:
	30a067->307067->309067->400->
	pra_addr list:
	4000->5000->2000->3000->
	=====in raound=====
	=====in raound=====
	=====in raound=====
	c0306010
	4000
	pte_addr list:
	307067->309067->400->
	pra_addr list:
	5000->2000->3000->
	swap_out: i 0, store page in vaddr 0x4000 to disk swap entry 5
	swap_in: load disk swap entry 4 with swap_page in vadr 0x3000
	write Virt Page d in _extended_clock_check_swap
	page fault at 0x00004000: K/W [no page found].
	pte_addr list:
	307067->309067->30a067->500->
	pra_addr list:
	5000->2000->3000->4000->
	=====in raound=====
	=====in raound=====
	=====in raound=====
	c0306014
	5000
	pte_addr list:
	309067->30a067->500->
	pra_addr list:
	2000->3000->4000->
	swap_out: i 0, store page in vaddr 0x5000 to disk swap entry 6
	swap_in: load disk swap entry 5 with swap_page in vadr 0x4000
	count is 0, total is 7
	check_swap() succeeded!
```

